"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const botframework_schema_1 = require("botframework-schema");
const messageFactory_1 = require("./messageFactory");
const cardFactory_1 = require("./cardFactory");
/**
 * The ActivityFactory
 * to generate text and then uses simple markdown semantics like chatdown to create Activity.
 */
class ActivityFactory {
    /**
     * Generate the activity.
     * @param lgResult string result from languageGenerator.
     */
    static fromObject(lgResult) {
        const diagnostics = this.checkLGResult(lgResult);
        const errors = diagnostics.filter((u) => u.startsWith(this.errorPrefix));
        if (errors !== undefined && errors.length > 0) {
            throw new Error(`${errors.join('\n')}`);
        }
        if (typeof lgResult === 'string') {
            const structuredLGResult = this.parseStructuredLGResult(lgResult.trim());
            return structuredLGResult === undefined ?
                this.buildActivityFromText(lgResult.trim())
                : this.buildActivityFromLGStructuredResult(lgResult);
        }
        return this.buildActivityFromLGStructuredResult(lgResult);
    }
    /**
     * check the LG result before generate an Activity.
     * @param lgResult lg output.
     * @returns Diagnostic list.
     */
    static checkLGResult(lgResult) {
        if (lgResult === undefined) {
            return [this.buildDiagnostic('LG output is empty', false)];
        }
        if (typeof lgResult === 'string') {
            if (!lgResult.startsWith('{') || !lgResult.endsWith('}')) {
                return [this.buildDiagnostic('LG output is not a json object, and will fallback to string format.', false)];
            }
            let lgStructuredResult = undefined;
            try {
                lgStructuredResult = JSON.parse(lgResult);
            }
            catch (error) {
                return [this.buildDiagnostic('LG output is not a json object, and will fallback to string format.', false)];
            }
            return this.checkStructuredResult(lgStructuredResult);
        }
        else {
            return this.checkStructuredResult(lgResult);
        }
    }
    /**
     * Given a lg result, create a text activity. This method will create a MessageActivity from text.
     * @param text lg text output.
     */
    static buildActivityFromText(text) {
        const msg = {
            type: botframework_schema_1.ActivityTypes.Message,
            text: text,
            speak: text
        };
        return msg;
    }
    /**
     * Given a structured lg result, create an activity. This method will create an MessageActivity from object
     * @param lgValue lg output.
     */
    static buildActivityFromLGStructuredResult(lgValue) {
        let activity = {};
        const type = this.getStructureType(lgValue);
        if (this.genericCardTypeMapping.has(type) || type === 'attachment') {
            activity = messageFactory_1.MessageFactory.attachment(this.getAttachment(lgValue));
        }
        else if (type === 'activity') {
            activity = this.buildActivity(lgValue);
        }
        else if (lgValue) {
            activity = this.buildActivityFromText(JSON.stringify(lgValue).trim());
        }
        return activity;
    }
    static buildActivity(messageValue) {
        let activity = { type: botframework_schema_1.ActivityTypes.Message };
        for (const key of Object.keys(messageValue)) {
            const property = key.trim();
            if (property === this.lgType) {
                continue;
            }
            const value = messageValue[key];
            switch (property.toLowerCase()) {
                case 'attachments':
                    activity.attachments = this.getAttachments(value);
                    break;
                case 'suggestedactions':
                    activity.suggestedActions = this.getSuggestions(value);
                    break;
                default:
                    var properties = this.activityProperties.map((u) => u.toLowerCase());
                    if (properties.includes(property.toLowerCase())) {
                        var realPropertyName = this.activityProperties[properties.indexOf(property.toLowerCase())];
                        activity[realPropertyName] = value;
                    }
                    else {
                        activity[property.toLowerCase()] = value;
                    }
                    break;
            }
        }
        return activity;
    }
    static getSuggestions(suggestionsValue) {
        const actions = this.normalizedToList(suggestionsValue);
        const suggestedActions = {
            actions: this.getCardActions(actions),
            to: []
        };
        return suggestedActions;
    }
    static getButtons(buttonsValue) {
        const actions = this.normalizedToList(buttonsValue);
        return this.getCardActions(actions);
    }
    static getCardActions(actions) {
        return actions.map((u) => this.getCardAction(u));
    }
    static getCardAction(action) {
        let cardAction;
        if (typeof action === 'string') {
            cardAction = { type: botframework_schema_1.ActionTypes.ImBack, value: action, title: action, channelData: undefined };
        }
        else {
            const type = this.getStructureType(action);
            cardAction = {
                type: botframework_schema_1.ActionTypes.ImBack,
                title: '',
                value: ''
            };
            if (type === 'cardaction') {
                for (const key of Object.keys(action)) {
                    const property = key.trim();
                    if (property === this.lgType) {
                        continue;
                    }
                    const value = action[key];
                    switch (property.toLowerCase()) {
                        case 'displaytext':
                            cardAction.displayText = value;
                            break;
                        case 'channeldata':
                            cardAction.channelData = value;
                            break;
                        default:
                            cardAction[property.toLowerCase()] = value;
                            break;
                    }
                }
            }
        }
        return cardAction;
    }
    static getAttachments(input) {
        const attachments = [];
        const attachmentsJsonList = this.normalizedToList(input);
        for (const attachmentsJson of attachmentsJsonList) {
            if (typeof attachmentsJson === 'object') {
                attachments.push(this.getAttachment(attachmentsJson));
            }
        }
        return attachments;
    }
    static getAttachment(input) {
        let attachment = {
            contentType: ''
        };
        const type = this.getStructureType(input);
        if (this.genericCardTypeMapping.has(type)) {
            attachment = this.getCardAttachment(this.genericCardTypeMapping.get(type), input);
        }
        else if (type === 'adaptivecard') {
            attachment = cardFactory_1.CardFactory.adaptiveCard(input);
        }
        else if (type === 'attachment') {
            attachment = this.getNormalAttachment(input);
        }
        else {
            attachment = { contentType: type, content: input };
        }
        return attachment;
    }
    static getNormalAttachment(input) {
        const attachment = { contentType: '' };
        for (const key of Object.keys(input)) {
            const property = key.trim();
            const value = input[key];
            switch (property.toLowerCase()) {
                case 'contenttype':
                    const type = value.toString().toLowerCase();
                    if (this.genericCardTypeMapping.has(type)) {
                        attachment.contentType = this.genericCardTypeMapping.get(type);
                    }
                    else if (type === 'adaptivecard') {
                        attachment.contentType = this.adaptiveCardType;
                    }
                    else {
                        attachment.contentType = type;
                    }
                    break;
                case 'contenturl':
                    attachment.contentUrl = value;
                    break;
                case 'thumbnailurl':
                    attachment.thumbnailUrl = value;
                    break;
                default:
                    attachment[property.toLowerCase()] = value;
                    break;
            }
        }
        return attachment;
    }
    static getCardAttachment(type, input) {
        const card = {};
        for (const key of Object.keys(input)) {
            const property = key.trim().toLowerCase();
            const value = input[key];
            switch (property) {
                case 'tap':
                    card[property] = this.getCardAction(value);
                    break;
                case 'image':
                case 'images':
                    if (type === cardFactory_1.CardFactory.contentTypes.heroCard || type === cardFactory_1.CardFactory.contentTypes.thumbnailCard) {
                        if (!('images' in card)) {
                            card['images'] = [];
                        }
                        const imageList = this.normalizedToList(value).map((u) => u.toString());
                        imageList.forEach((u) => card['images'].push({ url: u }));
                    }
                    else {
                        card['image'] = { url: value.toString() };
                    }
                    break;
                case 'media':
                    if (!('media' in card)) {
                        card['media'] = [];
                    }
                    const mediaList = this.normalizedToList(value).map((u) => u.toString());
                    mediaList.forEach((u) => card['media'].push({ url: u }));
                    break;
                case 'buttons':
                    if (!('buttons' in card)) {
                        card['buttons'] = [];
                    }
                    const buttons = this.getButtons(value);
                    buttons.forEach((u) => card[property].push(u));
                    break;
                case 'autostart':
                case 'shareable':
                case 'autoloop':
                    const boolValue = this.getValidBooleanValue(value.toString());
                    if (boolValue !== undefined) {
                        card[property] = boolValue;
                    }
                    break;
                case 'connectionname':
                    card['connectionName'] = value;
                    break;
                default:
                    card[property.toLowerCase()] = value;
                    break;
            }
        }
        const attachment = {
            contentType: type,
            content: card
        };
        return attachment;
    }
    static normalizedToList(item) {
        if (item === undefined) {
            return [];
        }
        else if (Array.isArray(item)) {
            return item;
        }
        else {
            return [item];
        }
    }
    static parseStructuredLGResult(lgStringResult) {
        let lgStructuredResult = undefined;
        if (lgStringResult === undefined || lgStringResult === '') {
            return undefined;
        }
        lgStringResult = lgStringResult.trim();
        if (lgStringResult === '' || !lgStringResult.startsWith('{') || !lgStringResult.endsWith('}')) {
            return undefined;
        }
        try {
            lgStructuredResult = JSON.parse(lgStringResult);
            const type = this.getStructureType(lgStringResult);
            if (!type || type.trim() === '') {
                return undefined;
            }
        }
        catch (error) {
            return undefined;
        }
        return lgStructuredResult;
    }
    static checkStructuredResult(input) {
        const result = [];
        const type = this.getStructureType(input);
        if (!type || type.trim() === '') {
            return result;
        }
        if (this.genericCardTypeMapping.has(type) || type === 'attachment') {
            result.push(...this.checkAttachment(input));
        }
        else if (type === 'activity') {
            result.push(...this.checkActivity(input));
        }
        else {
            const diagnosticMessage = `Type '${type}' is not supported currently.`;
            result.push(this.buildDiagnostic(diagnosticMessage, false));
        }
        return result;
    }
    static checkActivity(input) {
        const result = [];
        let activityType = undefined;
        if ('type' in input) {
            activityType = input['type'].toString().trim();
        }
        result.push(...this.checkActivityType(activityType));
        result.push(...this.checkActivityPropertyName(input));
        result.push(...this.checkActivityProperties(input));
        return result;
    }
    static checkActivityType(activityType) {
        if (activityType !== undefined) {
            if (!Object.values(botframework_schema_1.ActivityTypes).map((u) => u.toLowerCase()).includes(activityType.toLowerCase())) {
                return [this.buildDiagnostic(`'${activityType}' is not a valid activity type.`)];
            }
        }
        return [];
    }
    static checkActivityPropertyName(input) {
        const invalidProperties = [];
        for (const property of Object.keys(input)) {
            if (property === this.lgType) {
                continue;
            }
            if (!this.activityProperties.map((u) => u.toLowerCase()).includes(property.toLowerCase())) {
                invalidProperties.push(property);
            }
        }
        if (invalidProperties.length > 0) {
            return [this.buildDiagnostic(`'${invalidProperties.join(',')}' not support in Activity.`, false)];
        }
        return [];
    }
    static checkActivityProperties(input) {
        const result = [];
        for (const key of Object.keys(input)) {
            const property = key.trim();
            const value = input[key];
            switch (property.toLowerCase()) {
                case 'attachments':
                    result.push(...this.checkAttachments(value));
                    break;
                case 'suggestedactions':
                    result.push(...this.checkSuggestions(value));
                    break;
                default:
                    break;
            }
        }
        return result;
    }
    static checkSuggestions(value) {
        const actions = this.normalizedToList(value);
        return this.checkCardActions(actions);
    }
    static checkButtons(value) {
        const actions = this.normalizedToList(value);
        return this.checkCardActions(actions);
    }
    static checkCardActions(actions) {
        const result = [];
        actions.forEach((u) => { result.push(...this.checkCardAction(u)); });
        return result;
    }
    static checkCardAction(value) {
        const result = [];
        if (typeof value === 'string') {
            return result;
        }
        if (typeof value === 'object') {
            const type = this.getStructureType(value);
            if (type !== 'cardaction') {
                result.push(this.buildDiagnostic(`'${type}' is not card action type.`, false));
            }
            else {
                result.push(...this.checkCardActionPropertyName(value));
                if ('type' in value) {
                    result.push(...this.checkCardActionType(value['type']));
                }
            }
        }
        else {
            result.push(this.buildDiagnostic(`'${value}' is not a valid card action format.`, false));
        }
        return result;
    }
    static checkCardActionPropertyName(input) {
        const invalidProperties = [];
        for (const property of Object.keys(input)) {
            if (property === this.lgType) {
                continue;
            }
            if (!this.cardActionProperties.map((u) => u.toLowerCase()).includes(property.toLowerCase())) {
                invalidProperties.push(property);
            }
        }
        if (invalidProperties.length > 0) {
            return [this.buildDiagnostic(`'${invalidProperties.join(',')}' not support in card action.`, false)];
        }
        return [];
    }
    static checkCardActionType(cardActionType) {
        const result = [];
        if (!cardActionType) {
            return result;
        }
        if (!Object.values(botframework_schema_1.ActionTypes).map((u) => u.toLowerCase()).includes(cardActionType.toLowerCase())) {
            return [this.buildDiagnostic(`'${cardActionType}' is not a valid card action type.`)];
        }
        return result;
    }
    static checkAttachments(value) {
        const result = [];
        const attachmentsJsonList = this.normalizedToList(value);
        for (const attachmentsJson of attachmentsJsonList) {
            if (typeof attachmentsJson === 'object') {
                result.push(...this.checkAttachment(attachmentsJson));
            }
        }
        return result;
    }
    static checkAttachment(value) {
        const result = [];
        const type = this.getStructureType(value);
        if (this.genericCardTypeMapping.has(type)) {
            result.push(...this.checkCardAttachment(value));
        }
        else if (type === 'adaptivecard') {
            // TODO
            // check adaptivecard format
        }
        else if (type === 'attachment') {
            // TODO
            // Check attachment format
        }
        else {
            result.push(this.buildDiagnostic(`'${type}' is not an attachment type.`, false));
        }
        return result;
    }
    static checkCardAttachment(input) {
        const result = [];
        for (const key of Object.keys(input)) {
            const property = key.trim().toLowerCase();
            const value = input[key];
            switch (property) {
                case 'buttons':
                    result.push(...this.checkButtons(value));
                    break;
                case 'autostart':
                case 'shareable':
                case 'autoloop':
                    const boolValue = this.getValidBooleanValue(value.toString());
                    if (boolValue === undefined) {
                        result.push(this.buildDiagnostic(`'${value.toString()}' is not a boolean value.`));
                    }
                    break;
                default:
                    break;
            }
        }
        return result;
    }
    static getStructureType(input) {
        let result = '';
        if (input && typeof input === 'object') {
            if (this.lgType in input) {
                result = input[this.lgType].toString();
            }
            else if ('type' in input) {
                // Adaptive card type
                result = input['type'].toString();
            }
        }
        return result.trim().toLowerCase();
    }
    static getValidBooleanValue(boolValue) {
        if (boolValue.toLowerCase() === 'true') {
            return true;
        }
        else if (boolValue.toLowerCase() === 'false') {
            return false;
        }
        return undefined;
    }
    static buildDiagnostic(message, isError = true) {
        message = message === undefined ? '' : message;
        return isError ? this.errorPrefix + message : this.warningPrefix + message;
    }
}
ActivityFactory.lgType = 'lgType';
ActivityFactory.errorPrefix = '[ERROR]';
ActivityFactory.warningPrefix = '[WARNING]';
ActivityFactory.adaptiveCardType = cardFactory_1.CardFactory.contentTypes.adaptiveCard;
ActivityFactory.genericCardTypeMapping = new Map([
    ['herocard', cardFactory_1.CardFactory.contentTypes.heroCard],
    ['thumbnailcard', cardFactory_1.CardFactory.contentTypes.thumbnailCard],
    ['audiocard', cardFactory_1.CardFactory.contentTypes.audioCard],
    ['videocard', cardFactory_1.CardFactory.contentTypes.videoCard],
    ['animationcard', cardFactory_1.CardFactory.contentTypes.animationCard],
    ['signincard', cardFactory_1.CardFactory.contentTypes.signinCard],
    ['oauthcard', cardFactory_1.CardFactory.contentTypes.oauthCard],
    ['receiptcard', cardFactory_1.CardFactory.contentTypes.receiptCard],
]);
ActivityFactory.activityProperties = ['type', 'id', 'timestamp', 'localTimestamp', 'localTimezone', 'callerId',
    'serviceUrl', 'channelId', 'from', 'conversation', 'recipient', 'textFormat', 'attachmentLayout', 'membersAdded',
    'membersRemoved', 'reactionsAdded', 'reactionsRemoved', 'topicName', 'historyDisclosed', 'locale', 'text', 'speak',
    'inputHint', 'summary', 'suggestedActions', 'attachments', 'entities', 'channelData', 'action', 'replyToId', 'label',
    'valueType', 'value', 'name', 'typrelatesToe', 'code', 'expiration', 'importance', 'deliveryMode', 'listenFor',
    'textHighlights', 'semanticAction'];
ActivityFactory.cardActionProperties = ['type', 'title', 'image', 'text', 'displayText', 'value', 'channelData'];
exports.ActivityFactory = ActivityFactory;
//# sourceMappingURL=activityFactory.js.map